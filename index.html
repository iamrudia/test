<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HTML Tetris</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1b33;
      --grid:#0a1020;
      --border:#22345a;
      --text:#e9f0ff;
      --muted:#a9b7d6;
      --accent:#6ee7ff;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
      background: radial-gradient(1200px 800px at 20% 10%, #13264f 0%, var(--bg) 55%, #070b14 100%);
      color: var(--text);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
    }
    .wrap{
      display:grid;
      grid-template-columns: 1fr 280px;
      gap:18px;
      align-items:start;
      max-width: 860px;
      width: 100%;
    }
    .game{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius:18px;
      padding:16px;
      box-shadow: var(--shadow);
    }
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
    }
    .title{
      display:flex; align-items:baseline; gap:10px;
    }
    .title h1{
      font-size:18px; margin:0; letter-spacing:.2px;
    }
    .badge{
      font-size:12px;
      color: #06202a;
      background: linear-gradient(90deg, var(--accent), #7cffc5);
      padding:2px 8px;
      border-radius:999px;
      font-weight:700;
    }
    .controls{
      display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;
    }
    button{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:650;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    button:hover{ background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.18); }
    button:active{ transform: translateY(1px); }
    .stage{
      display:grid;
      grid-template-columns: auto 140px;
      gap:16px;
      align-items:start;
    }
    canvas{
      background: radial-gradient(800px 600px at 50% 20%, rgba(110,231,255,.10), transparent 55%),
                  linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      width:100%;
      height:auto;
      display:block;
    }
    .side{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .panel{
      background: rgba(15,27,51,.65);
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      padding:12px;
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
    }
    .panel h2{
      margin:0 0 10px 0;
      font-size:13px;
      color: var(--muted);
      letter-spacing:.3px;
      text-transform:uppercase;
    }
    .stat{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:6px 10px;
      align-items:center;
      font-size:14px;
    }
    .stat .k{ color: var(--muted); }
    .stat .v{ font-variant-numeric: tabular-nums; font-weight:800; }
    .mini{
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius:14px;
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.08);
      display:block;
    }
    .hint{
      color: var(--muted);
      font-size:13px;
      line-height:1.4;
    }
    .kbd{
      display:inline-block;
      padding:1px 6px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.07);
      color: var(--text);
      font-weight:700;
      font-size:12px;
      margin:0 2px;
    }
    .overlay{
      position:relative;
    }
    .msg{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:18px;
      background: rgba(0,0,0,.55);
      border-radius:16px;
      backdrop-filter: blur(6px);
    }
    .msg.show{ display:flex; }
    .msg .box{
      max-width: 360px;
      background: rgba(15,27,51,.85);
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      padding:14px 16px;
      box-shadow: var(--shadow);
    }
    .msg h3{ margin:0 0 6px 0; font-size:18px; }
    .msg p{ margin:0; color: var(--muted); }
    @media (max-width: 820px){
      .wrap{ grid-template-columns: 1fr; }
      .stage{ grid-template-columns: 1fr; }
      .side{ flex-direction:row; flex-wrap:wrap; }
      .panel{ flex:1 1 220px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="game">
      <div class="topbar">
        <div class="title">
          <h1>HTML Tetris</h1>
          <span class="badge">Vanilla JS</span>
        </div>
        <div class="controls">
          <button id="btnStart">시작</button>
          <button id="btnPause">일시정지(P)</button>
          <button id="btnReset">재시작(R)</button>
        </div>
      </div>

      <div class="stage">
        <div class="overlay">
          <canvas id="board" width="300" height="600" aria-label="tetris board"></canvas>
          <div id="msg" class="msg">
            <div class="box">
              <h3 id="msgTitle">Paused</h3>
              <p id="msgBody">P 키로 다시 시작할 수 있어요.</p>
            </div>
          </div>
        </div>

        <div class="side">
          <div class="panel">
            <h2>Next</h2>
            <canvas id="next" class="mini" width="140" height="140"></canvas>
          </div>

          <div class="panel">
            <h2>Stats</h2>
            <div class="stat">
              <div class="k">Score</div><div class="v" id="score">0</div>
              <div class="k">Lines</div><div class="v" id="lines">0</div>
              <div class="k">Level</div><div class="v" id="level">1</div>
            </div>
          </div>

          <div class="panel">
            <h2>Keys</h2>
            <div class="hint">
              <div><span class="kbd">←</span><span class="kbd">→</span> 이동</div>
              <div><span class="kbd">↑</span> 회전</div>
              <div><span class="kbd">↓</span> 소프트 드롭</div>
              <div><span class="kbd">Space</span> 하드 드롭</div>
              <div><span class="kbd">P</span> 일시정지</div>
              <div><span class="kbd">R</span> 재시작</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h2>Tips</h2>
      <div class="hint">
        - 줄을 한 번에 많이 지울수록 점수가 커져요.<br>
        - 레벨이 오르면 자동 낙하 속도가 빨라져요.<br>
        - 코드에서 보드 크기(10x20), 블록 색, 점수식을 바꿔 커스터마이징할 수 있어요.
      </div>
    </div>
  </div>

  <script>
    // ====== Config ======
    const COLS = 10;
    const ROWS = 20;
    const BLOCK = 30; // px for board canvas scale (canvas is sized accordingly)

    const boardCanvas = document.getElementById('board');
    const ctx = boardCanvas.getContext('2d');

    const nextCanvas = document.getElementById('next');
    const nctx = nextCanvas.getContext('2d');

    // Scale canvas to grid
    boardCanvas.width = COLS * BLOCK;
    boardCanvas.height = ROWS * BLOCK;

    const ui = {
      score: document.getElementById('score'),
      lines: document.getElementById('lines'),
      level: document.getElementById('level'),
      msg: document.getElementById('msg'),
      msgTitle: document.getElementById('msgTitle'),
      msgBody: document.getElementById('msgBody'),
      btnStart: document.getElementById('btnStart'),
      btnPause: document.getElementById('btnPause'),
      btnReset: document.getElementById('btnReset')
    };

    const COLORS = {
      I: '#55E6FF',
      O: '#FFD166',
      T: '#B388FF',
      S: '#7CFFB2',
      Z: '#FF6B6B',
      J: '#4D7CFF',
      L: '#FF9F59',
      GHOST: 'rgba(255,255,255,0.18)',
      GRID: 'rgba(255,255,255,0.06)'
    };

    // Tetromino definitions (4x4 matrix)
    const SHAPES = {
      I: [
        [0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0]
      ],
      O: [
        [0,1,1,0],
        [0,1,1,0],
        [0,0,0,0],
        [0,0,0,0]
      ],
      T: [
        [0,1,0,0],
        [1,1,1,0],
        [0,0,0,0],
        [0,0,0,0]
      ],
      S: [
        [0,1,1,0],
        [1,1,0,0],
        [0,0,0,0],
        [0,0,0,0]
      ],
      Z: [
        [1,1,0,0],
        [0,1,1,0],
        [0,0,0,0],
        [0,0,0,0]
      ],
      J: [
        [1,0,0,0],
        [1,1,1,0],
        [0,0,0,0],
        [0,0,0,0]
      ],
      L: [
        [0,0,1,0],
        [1,1,1,0],
        [0,0,0,0],
        [0,0,0,0]
      ]
    };

    const PIECES = Object.keys(SHAPES);

    function createMatrix(rows, cols, fill = null){
      return Array.from({length: rows}, () => Array.from({length: cols}, () => fill));
    }

    // Rotate 4x4 matrix clockwise
    function rotate(matrix){
      const N = matrix.length;
      const out = createMatrix(N, N, 0);
      for(let y=0; y<N; y++){
        for(let x=0; x<N; x++){
          out[x][N-1-y] = matrix[y][x];
        }
      }
      return out;
    }

    function cloneMatrix(m){
      return m.map(row => row.slice());
    }

    function randPiece(){
      const type = PIECES[(Math.random() * PIECES.length) | 0];
      return {
        type,
        matrix: cloneMatrix(SHAPES[type]),
        x: ((COLS / 2) | 0) - 2,
        y: -1
      };
    }

    // ====== Game State ======
    let board, current, next;
    let score = 0, lines = 0, level = 1;
    let dropInterval = 800; // ms
    let lastTime = 0;
    let dropCounter = 0;
    let running = false;
    let paused = false;
    let gameOver = false;

    // ====== Collision / Merge ======
    function collides(b, piece){
      const m = piece.matrix;
      for(let y=0; y<4; y++){
        for(let x=0; x<4; x++){
          if(!m[y][x]) continue;
          const bx = piece.x + x;
          const by = piece.y + y;

          // below bottom
          if(by >= ROWS) return true;
          // off left/right
          if(bx < 0 || bx >= COLS) return true;
          // above top is allowed (spawn area)
          if(by < 0) continue;
          if(b[by][bx]) return true;
        }
      }
      return false;
    }

    function merge(b, piece){
      const m = piece.matrix;
      for(let y=0; y<4; y++){
        for(let x=0; x<4; x++){
          if(!m[y][x]) continue;
          const bx = piece.x + x;
          const by = piece.y + y;
          if(by >= 0 && by < ROWS && bx >= 0 && bx < COLS){
            b[by][bx] = piece.type;
          }
        }
      }
    }

    function clearLines(){
      let cleared = 0;
      outer:
      for(let y = ROWS - 1; y >= 0; y--){
        for(let x = 0; x < COLS; x++){
          if(!board[y][x]) continue outer;
        }
        // full row
        board.splice(y, 1);
        board.unshift(Array.from({length: COLS}, () => null));
        cleared++;
        y++; // recheck same y after shifting
      }

      if(cleared > 0){
        // scoring (classic-ish): 1=100,2=300,3=500,4=800 * level
        const table = [0, 100, 300, 500, 800];
        score += (table[cleared] || 0) * level;
        lines += cleared;

        // level up every 10 lines
        const newLevel = Math.floor(lines / 10) + 1;
        if(newLevel !== level){
          level = newLevel;
          // speed up (lower interval), clamp minimum
          dropInterval = Math.max(120, 800 - (level - 1) * 60);
        }
        updateUI();
      }
    }

    function hardDrop(){
      if(!running || paused || gameOver) return;
      let p = {...current};
      // move down until collision
      while(!collides(board, p)){
        current.y = p.y;
        p.y++;
      }
      // lock
      lockPiece();
    }

    function lockPiece(){
      merge(board, current);
      clearLines();
      spawnNext();
      // if new piece collides immediately => game over
      if(collides(board, current)){
        endGame();
      }
    }

    function spawnNext(){
      current = next || randPiece();
      next = randPiece();
      drawNext();
    }

    // ====== Movement ======
    function move(dx){
      if(!running || paused || gameOver) return;
      const p = {...current, x: current.x + dx};
      if(!collides(board, p)) current.x += dx;
    }

    function softDrop(){
      if(!running || paused || gameOver) return;
      const p = {...current, y: current.y + 1};
      if(!collides(board, p)){
        current.y++;
        score += 1; // tiny reward for manual drop
        updateUI();
      } else {
        lockPiece();
      }
      dropCounter = 0;
    }

    function rotatePiece(){
      if(!running || paused || gameOver) return;
      const rotated = rotate(current.matrix);

      // simple wall-kick: try offsets
      const kicks = [0, -1, 1, -2, 2];
      for(const k of kicks){
        const p = {...current, matrix: rotated, x: current.x + k};
        if(!collides(board, p)){
          current.matrix = rotated;
          current.x += k;
          return;
        }
      }
    }

    function getGhostPiece(){
      const ghost = {...current, matrix: current.matrix.map(r=>r.slice())};
      while(!collides(board, {...ghost, y: ghost.y + 1})){
        ghost.y++;
      }
      return ghost;
    }

    // ====== Rendering ======
    function clearCanvas(c, w, h){
      c.clearRect(0, 0, w, h);
    }

    function drawGrid(){
      ctx.save();
      ctx.strokeStyle = COLORS.GRID;
      ctx.lineWidth = 1;
      for(let x=0; x<=COLS; x++){
        ctx.beginPath();
        ctx.moveTo(x*BLOCK + 0.5, 0);
        ctx.lineTo(x*BLOCK + 0.5, ROWS*BLOCK);
        ctx.stroke();
      }
      for(let y=0; y<=ROWS; y++){
        ctx.beginPath();
        ctx.moveTo(0, y*BLOCK + 0.5);
        ctx.lineTo(COLS*BLOCK, y*BLOCK + 0.5);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawCell(x, y, color, alpha = 1){
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK, BLOCK);

      // highlight
      ctx.globalAlpha = alpha * 0.18;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(x*BLOCK + 2, y*BLOCK + 2, BLOCK - 4, (BLOCK - 4) * 0.35);

      // border
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x*BLOCK + 0.5, y*BLOCK + 0.5, BLOCK - 1, BLOCK - 1);
      ctx.restore();
    }

    function drawBoard(){
      clearCanvas(ctx, boardCanvas.width, boardCanvas.height);

      // background grid
      drawGrid();

      // placed blocks
      for(let y=0; y<ROWS; y++){
        for(let x=0; x<COLS; x++){
          const t = board[y][x];
          if(t){
            drawCell(x, y, COLORS[t]);
          }
        }
      }

      // ghost
      if(running && !paused && !gameOver){
        const ghost = getGhostPiece();
        drawPiece(ghost, COLORS.GHOST, 1);
      }

      // current piece
      if(running && !gameOver){
        drawPiece(current, COLORS[current.type], 1);
      }
    }

    function drawPiece(piece, color, alpha=1){
      const m = piece.matrix;
      for(let y=0; y<4; y++){
        for(let x=0; x<4; x++){
          if(!m[y][x]) continue;
          const bx = piece.x + x;
          const by = piece.y + y;
          if(by < 0) continue;
          drawCell(bx, by, color, alpha);
        }
      }
    }

    function drawNext(){
      clearCanvas(nctx, nextCanvas.width, nextCanvas.height);
      const m = next.matrix;
      const size = 28; // mini block size
      const ox = 14;   // offset
      const oy = 14;

      // draw a faint grid
      nctx.save();
      nctx.strokeStyle = 'rgba(255,255,255,0.08)';
      for(let i=0;i<=4;i++){
        nctx.beginPath();
        nctx.moveTo(ox + i*size + 0.5, oy);
        nctx.lineTo(ox + i*size + 0.5, oy + 4*size);
        nctx.stroke();
        nctx.beginPath();
        nctx.moveTo(ox, oy + i*size + 0.5);
        nctx.lineTo(ox + 4*size, oy + i*size + 0.5);
        nctx.stroke();
      }
      nctx.restore();

      // center piece in mini canvas by finding bounds
      let minX=4, minY=4, maxX=0, maxY=0;
      for(let y=0;y<4;y++){
        for(let x=0;x<4;x++){
          if(m[y][x]){
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
        }
      }
      const w = (maxX - minX + 1);
      const h = (maxY - minY + 1);
      const px = ox + ((4 - w) * size)/2;
      const py = oy + ((4 - h) * size)/2;

      for(let y=0;y<4;y++){
        for(let x=0;x<4;x++){
          if(!m[y][x]) continue;
          const xx = px + (x - minX) * size;
          const yy = py + (y - minY) * size;

          nctx.save();
          nctx.fillStyle = COLORS[next.type];
          nctx.fillRect(xx, yy, size, size);

          nctx.globalAlpha = 0.18;
          nctx.fillStyle = '#fff';
          nctx.fillRect(xx+2, yy+2, size-4, (size-4)*0.35);

          nctx.globalAlpha = 1;
          nctx.strokeStyle = 'rgba(255,255,255,0.18)';
          nctx.strokeRect(xx+0.5, yy+0.5, size-1, size-1);
          nctx.restore();
        }
      }
    }

    function updateUI(){
      ui.score.textContent = score;
      ui.lines.textContent = lines;
      ui.level.textContent = level;
    }

    function showMessage(title, body){
      ui.msgTitle.textContent = title;
      ui.msgBody.textContent = body;
      ui.msg.classList.add('show');
    }

    function hideMessage(){
      ui.msg.classList.remove('show');
    }

    // ====== Loop ======
    function update(time = 0){
      if(!running){
        drawBoard();
        return;
      }
      if(paused || gameOver){
        drawBoard();
        requestAnimationFrame(update);
        return;
      }

      const delta = time - lastTime;
      lastTime = time;
      dropCounter += delta;

      if(dropCounter > dropInterval){
        // auto drop
        const p = {...current, y: current.y + 1};
        if(!collides(board, p)){
          current.y++;
        } else {
          lockPiece();
        }
        dropCounter = 0;
      }

      drawBoard();
      requestAnimationFrame(update);
    }

    // ====== Game Controls ======
    function start(){
      if(running && !gameOver) return;
      if(gameOver) reset();
      running = true;
      paused = false;
      hideMessage();
      lastTime = 0;
      requestAnimationFrame(update);
    }

    function togglePause(){
      if(!running || gameOver) return;
      paused = !paused;
      if(paused){
        showMessage('Paused', 'P 키로 다시 시작할 수 있어요.');
      }else{
        hideMessage();
        lastTime = performance.now();
      }
    }

    function reset(){
      board = createMatrix(ROWS, COLS, null);
      score = 0; lines = 0; level = 1;
      dropInterval = 800;
      running = true;
      paused = false;
      gameOver = false;
      next = randPiece();
      spawnNext();
      updateUI();
      hideMessage();
      lastTime = 0;
      dropCounter = 0;
      requestAnimationFrame(update);
    }

    function endGame(){
      gameOver = true;
      running = true; // keep rendering
      showMessage('Game Over', 'R 키로 재시작할 수 있어요.');
    }

    // ====== Input ======
    document.addEventListener('keydown', (e) => {
      const key = e.key;

      // prevent page scrolling with arrows/space
      if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' '].includes(key)){
        e.preventDefault();
      }

      if(key === 'p' || key === 'P') togglePause();
      if(key === 'r' || key === 'R') reset();

      if(!running || paused || gameOver) {
        // allow start with Enter
        if(key === 'Enter') start();
        return;
      }

      if(key === 'ArrowLeft') move(-1);
      else if(key === 'ArrowRight') move(1);
      else if(key === 'ArrowDown') softDrop();
      else if(key === 'ArrowUp') rotatePiece();
      else if(key === ' ') hardDrop();
    });

    // Buttons
    ui.btnStart.addEventListener('click', start);
    ui.btnPause.addEventListener('click', togglePause);
    ui.btnReset.addEventListener('click', reset);

    // ====== Init (start state) ======
    function init(){
      board = createMatrix(ROWS, COLS, null);
      current = randPiece();
      next = randPiece();
      drawNext();
      updateUI();
      showMessage('Ready', '시작 버튼 또는 Enter 키로 시작해요.');
      drawBoard();
      requestAnimationFrame(update);
    }
    init();
  </script>
</body>
</html>
